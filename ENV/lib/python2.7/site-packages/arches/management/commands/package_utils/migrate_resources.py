import os
import sys
import traceback
import unicodecsv
from os import listdir
from os.path import isfile, join
import arches.app.models.models as models
from arches.app.models.entity import Entity
from arches.app.models.resource import Resource
from django.db.models import Q


from itertools import groupby

import logging

# Script for migrating business data from one part of resource graph to elsewhere.
# Typically this will be part of a migration from one resource graph to another, after adding new parts from the new resource graph, but before removing old ones.
# The migration is carried out according to a csv which specifies which entities must be created or altered.


def migrate(settings=None):
    
    if not settings:
        from django.conf import settings
    
    suffix = '_altered_nodes.csv'
    errors = []
    
    for path in settings.ADDITIONAL_RESOURCE_GRAPH_LOCATIONS:
        if os.path.exists(path):
            print '\nLOADING NODE MIGRATION INFO (%s)' % (path)
            print '--------------'
            for f in listdir(path):
                if isfile(join(path, f)) and f.endswith(suffix):
                    path_to_file = join(path,f)
                    basepath = path_to_file[:-18]
                    name = basepath.split(os.sep)[-1]
                    
                    migrations = get_list_dict(basepath + '_altered_nodes.csv', ['OLDENTITYTYPEID', 'NEWENTITYTYPEID', 'GROUPROOTNODEOLD', 'GROUPROOTNODENEW'])
                
                    # include any rules about observed property nodes which must be inserted
                    for migration in migrations:
                        for parent in settings.ADD_OBSERVED_NEAR:
                            if settings.ADD_OBSERVED_NEAR[parent][0] == migration['NEWENTITYTYPEID']:
                                migration['INSERT_NODE_RULE'] = (parent, settings.ADD_OBSERVED_NEAR[parent])
                    
                    
                    # Identify nodes which must be migrated
                    resource_entity_type = 'HERITAGE_RESOURCE_GROUP.E27'
                    mapping_schema = Entity.get_mapping_schema(resource_entity_type)
                    
                    # group migrations by groupRootNodeNew
                    groups = groupby(migrations, lambda x:(x['GROUPROOTNODEOLD'], x['GROUPROOTNODENEW']))
                    
                    for group_root_node_ids, group_migrations in groups:
                        
                        #Convert group_migrations to a list as we need to iterate it multiple times
                        group_migrations_list = []
                        for group_migration in group_migrations:
                            group_migrations_list.append(group_migration)
                        
                        group_root_node_id = group_root_node_ids[0]
                        new_group_root_node_id = group_root_node_ids[1]
                        
                        #Find all entities with the old group root node
                        group_root_entities = models.Entities.objects.all().filter(entitytypeid=group_root_node_id)
                        
                        for group_root_entity_model in group_root_entities:
                            # Create a new subgraph for each of the migration steps, then merge them together at the group root node
                            
                            #get full resource graph for the root entity
                            group_root_entity = Entity(group_root_entity_model.pk)
                            
                            # create a node for the new group root
                            new_group_root_entity = Entity().create_from_mapping(resource_entity_type, mapping_schema[new_group_root_node_id]['steps'], new_group_root_node_id, '')
                            
                            # get the root resource graph for this entity
                            resource_model = get_resource_for_entity(group_root_entity, resource_entity_type)
                            resource = Resource().get(resource_model.entityid)
                            
                            
                            for group_migration in group_migrations_list:
                                
                                # get individual entities to be migrated in the source group
                                old_entities = group_root_entity.find_entities_by_type_id(group_migration['OLDENTITYTYPEID'])
                                
                                for old_entity in old_entities:
                                    # Create the corresponding entity in the new schema
                                    new_entity = Entity()
                                    new_entity_type_id = group_migration['NEWENTITYTYPEID']
                                    new_entity.create_from_mapping(resource_entity_type, mapping_schema[new_entity_type_id]['steps'], new_entity_type_id, old_entity.value)
                                    
                                    # If there is a node to be inserted, do it here
                                    if 'INSERT_NODE_RULE' in group_migration:
                                        entityttypeid_to_insert = group_migration['INSERT_NODE_RULE'][1][1]
                                        value_to_insert = group_migration['INSERT_NODE_RULE'][1][2]
                                        
                                        inserted_entity = Entity()
                                        inserted_entity.create_from_mapping(resource_entity_type, mapping_schema[entityttypeid_to_insert]['steps'], entityttypeid_to_insert, value_to_insert)
                                        
                                        new_entity.merge(inserted_entity)
                                        
                                    # If there is a node in common with the existing node further down the chain than the group root node, merge there
                                    # follow links back from the parent
                    
                                    has_merged = False
                                    
                                    reversed_steps = mapping_schema[new_entity_type_id]['steps'][::-1]
                                    for step in reversed_steps:
                                        # find the entitytypedomain in the new_group_root_entity
                                        if not has_merged:
                                            mergeable_nodes = new_group_root_entity.find_entities_by_type_id(step['entitytypedomain'])
                                            if len(mergeable_nodes) > 0:
                                                new_group_root_entity.merge_at(new_entity, step['entitytypedomain'])
                                                has_merged = True
                                    
                                    if not has_merged:
                                        logging.warning("Unable to merge newly created entity")
                                    
                                    
                                # merge the new group root entity into the resource
                                resource.merge_at(new_group_root_entity, resource_entity_type)
                            
                            
                            # save the resource
                            resource.trim()
                            resource._save()
                            # resource.index()
                            logging.warning("SAVED RESOURCE, %s", resource)
                            
                            
                        
                        # TODO leave this blank?
                        # if not group_root_node_id:
                        #     #No grouping of these nodes. Just insert the new ones.
                        #     
                        #     for migration in migrations:
                        #         # For each node to be migrated
                        #         node_id = migration['OLDENTITYTYPEID']
                        #         
                        #         # Find affected entities
                        #         entities = models.Entities.objects.all().filter(entitytypeid=node_id)
                        #         
                        #         
                        #         new_type_id = migration['NEWENTITYTYPEID']
                        #         
                        #         for resource_entity in entities:
                        #             # create a new entity with the value taken from the old type
                        #             
                        #             # load the original entity from the database
                        #             original_entity = Entity(resource_entity.pk)
                        #             
                        #             # Find the full resource the source entity came from
                        #             # Trace back through entity relations until we arrive the root type
                        #             resource_model = get_resource_for_entity(resource_entity)
                        #             resource = Resource(resource_model.pk)
                        #             resource.set_entity_value(new_type_id, original_entity.value, append=True)
                        #             log_entity(resource)
                        #             resource._save()
                        #             resource.index()
                        #         
                        
        

def insert_actors(settings=None):
    
    if not settings:
        from django.conf import settings
        
    logging.warning("INSERTING ACTORS")
    
    resource_entity_type = 'HERITAGE_RESOURCE_GROUP.E27'
    mapping_schema = Entity.get_mapping_schema(resource_entity_type)
    
    # access settings to determine which actor nodes should correspond to editors of which pre-existing nodes
    for entry in settings.ACTOR_NODES:
        
        # find all entities of the parent type
        actor_entitytypeid = entry[0]
        parent_entitytypeid = entry[1]
        source_entitytypeid = entry[2]
        
        mapping_step_to_actor = mapping_schema[actor_entitytypeid]['steps'][-1]
        
        parent_entities = models.Entities.objects.all().filter(entitytypeid=parent_entitytypeid)
        
        for parent_entity_model in parent_entities:
            # check whether an actor node already exists
            parent_entity = Entity().get(parent_entity_model.entityid)
            actors = parent_entity.find_entities_by_type_id(actor_entitytypeid)
            if(len(actors) == 0):
                # get the root resource
                root_resource_model = get_resource_for_entity(parent_entity_model, resource_entity_type)
                
                # find the last edit to the node that the data originated at
                edits = models.EditLog.objects.all().filter(resourceid=root_resource_model.entityid, attributeentitytypeid=source_entitytypeid).order_by('timestamp')
                first_edit = edits[0]
                actor_name = '%s %s' % (edits[0].user_firstname, edits[0].user_lastname)
                
                # create the actor node
                parent_entity.add_child_entity(actor_entitytypeid, mapping_step_to_actor['propertyid'], actor_name, '')
                
                # logging.warning("\n\nParent after insert")
                log_entity(parent_entity)
                parent_entity._save()
                
                root_resource = Resource()
                root_resource.get(root_resource_model.entityid)
                

def prune_ontology(settings=None):
    
    if not settings:
        from django.conf import settings
        
    suffix = '_removed_nodes.csv'
    
    for path in settings.ADDITIONAL_RESOURCE_GRAPH_LOCATIONS:
        if os.path.exists(path):
            for f in listdir(path):
                if isfile(join(path,f)) and f.endswith(suffix):
                    path_to_file = join(path,f)
                    basepath = path_to_file[:-18]
                    name = basepath.split(os.sep)[-1]
                    
                    nodes_to_remove = get_list_dict(basepath + '_removed_nodes.csv', ['NodeId'])
                    
                    all_entitytypeids_to_remove = [x['NodeId'] for x in nodes_to_remove]
                    
                    
                    ### Remove entities and their associated values/relationships
                    entities_to_delete = models.Entities.objects.all().filter(entitytypeid__in=all_entitytypeids_to_remove)
                    print "Deleting %s data entities and associated values and relations" % len(entities_to_delete)
                    # delete any value records for this entity id
                    # dates
                    models.Dates.objects.all().filter(entityid__in=entities_to_delete).delete()
                    # files
                    models.Files.objects.all().filter(entityid__in=entities_to_delete).delete()
                    # strings
                    models.Strings.objects.all().filter(entityid__in=entities_to_delete).delete()
                    # geometries
                    models.Geometries.objects.all().filter(entityid__in=entities_to_delete).delete()
                    # numbers
                    models.Numbers.objects.all().filter(entityid__in=entities_to_delete).delete()
                    # domains
                    models.Domains.objects.all().filter(entityid__in=entities_to_delete).delete()
                    # delete any relationships from or to this entity id
                    models.Relations.objects.all().filter( Q(entityiddomain__in=entities_to_delete) | Q(entityidrange__in=entities_to_delete) ).delete()
                    # delete the entity record
                    entities_to_delete.delete()
                        

                    #### Prune the ontology
                    
                    print "Removing entity types from ontology data (entity types, mappings, mapping_steps, and rules)"
                    # remove mappings to these entitytype if there is one
                    models.Mappings.objects.all().filter(entitytypeidto__in=all_entitytypeids_to_remove).delete()
                    
                    # find rules involving this entity type
                    rules = models.Rules.objects.all().filter( Q(entitytypedomain__in=all_entitytypeids_to_remove) | Q(entitytyperange__in=all_entitytypeids_to_remove))
                    # remove mapping steps associated to these rules
                    models.MappingSteps.objects.all().filter(ruleid__in=rules).delete()
                    # remove the rules
                    rules.delete()
                    
                    # delete the entity_types themselves
                    entity_types = models.EntityTypes.objects.all().filter(entitytypeid__in=all_entitytypeids_to_remove).delete()
                        
                    # QUESTION: What if we are removing nodes in the middle of a mapping chain, but leaving the tips intact?
                    # Will this cause any problems? Perhaps the onus is on the user to include all relevant nodes
                    
                    logging.warning("Removed all entities and ontology data related to the following entity types: %s", all_entitytypeids_to_remove)

def log_entity(entity):
    def do_log(subentity):
        logging.warning("--%s--", subentity)
    logging.warning("------Logging entity")
    entity.traverse(do_log)
    logging.warning("------End log entity")

def get_resource_for_entity(entity, resource_entity_type_id):
    parent = entity
    typeid = parent.entitytypeid
    try:
        while typeid != resource_entity_type_id:
            relationship = models.Relations.objects.all().get(entityidrange=parent.entityid)
            parent = relationship.entityiddomain
            typeid = parent.entitytypeid.pk
        return parent
    except Exception as err:
        logging.warning("Couldn't find root resource. %s", err)
        return None
    
    
def get_list_dict(pathtofile, fieldnames):
    """
    Gets a list of dictionaries from a csv file

    """

    ret = []
    with open(pathtofile, 'rU') as f:
        rows = unicodecsv.DictReader(f, fieldnames=fieldnames, 
            encoding='utf-8-sig', delimiter=',', restkey='ADDITIONAL', restval='MISSING')
        rows.next() # skip header row
        for row in rows:  
            ret.append(row)
    return ret